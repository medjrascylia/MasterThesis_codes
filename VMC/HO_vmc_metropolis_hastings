// Variational Monte Carlo for the harmonic oscillator using Metropolisâ€“Hastings to calculate the ground state energy and variance


#include<iostream>
#include<cstdlib>
#include<cmath>
#include<iomanip>
#include<ctime>
#include<fstream>

#define t 0.005
#define PI 4.*atan(1.)

using namespace std;


double loi_uniforme(){
	return (rand()/(double)RAND_MAX);
}

double wf(double xi, double a){
	return  exp(-0.5*a*a*xi*xi);
}

double LocalEnergy(double xi, double a){

	return 0.5*xi*xi*(1.-pow(a,4))+0.5*a*a;
}

double F(double xi,double a){
	return (-2*a*a*xi);
}

double loi_normale(double mu,double sigma ){
	double u,v,x;
	u=loi_uniforme();
	v=loi_uniforme();
	x=sqrt(-2*log(u))*cos(2*PI*v);
	return (sigma*x+mu);}

double green(double x1, double x2,double a){

double x=(x1-x2-0.5*F(x2,a)*t)*(x1-x2-0.5*F(x2,a)*t);
	return exp(-.5*x/t);} 

int main(){

ofstream f;
f.open("HO_MH.data");

int mc;
double a,apas=0.05,ratio2;
double energy, energy2, variance, error,ratio;
double owf,nwf,xi,x0;
int mcCycles = 20000000;

srand(time(0));
	for( a=0.4; a <= 2; a+= apas){
	//initalization
		x0= loi_uniforme();
		energy=0;
		energy2=0;
		for(mc=1;mc<=mcCycles ; mc++){
		// shifting the walker
		xi = x0 + 0.5*F(x0,a)*t +                 

                loi_normale(0,sqrt(t));
                 owf=wf(x0,a); 
                  nwf=wf(xi,a);
		//Metropolis test     

	    ratio2 =green(x0,xi,a)/green(xi,x0,a); 
	    ratio = ratio2*(nwf*nwf/(owf*owf));
	    double r = loi_uniforme();
	       if( r<= ratio){
		x0 = xi;
		owf= nwf;} 
	    energy+= LocalEnergy(x0,a);
	    energy2 += LocalEnergy(x0,a) * LocalEnergy(x0,a);	
	}
energy /= mcCycles;
	energy2 /= mcCycles;
	variance = energy2 - energy*energy;
	error = sqrt(variance/mcCycles);
	cout << a << "\t" << energy << "\t" << variance  << "\t" <<error<< endl;
	
	f << a <<"\t" << energy <<"\t"<< variance << endl;
	
}

return 0;}
